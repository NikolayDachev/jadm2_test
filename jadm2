#!/usr/bin/env python
########################################################################################
# Jadm license information
#
'''
Copyright (c) <2015>, <Nikolay Georgiev Dachev> <nikolay@dachev.info>
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''
########################################################################################
# Python modules
# datetime - used for current date/time on event
# tabulate - used to print useful infomration in table format
# os, sys, subprocess - used for comunication with FreeBSD
# netifaces - used for check FreeBSD bridge interfaces
# ipaddress - used to check if jail ip is from gateway network
# cmd - used for jadm command shell
# paramiko - used for jail migration via ssh
# socket - jadm client/server
# AES - aes encryption
# base64 aes encription help

from datetime import datetime
from tabulate import tabulate
from ipaddress import *
import sys
import os
import logging
import subprocess
import netifaces
import cmd
import paramiko
import socket
from Crypto.Cipher import AES
import base64

########################################################################################
# Main config vars:
########################################################################################

# jadm version
jadm_version = "ver. 2.0"

# jail.conf location by default /etc/jail.conf
jailconf = '/etc/jail.conf'

# jadm log file
logfile = '/var/log/jadm.log'

# jadm don't show verbose output by defult
verbose = 0

# settings start index in jail.conf
_Lsettings = '#@#localsettings#@#'

# jadm server
LHOST = '0.0.0.0'
LPORT = 4555

# network config
# newmac generate random mac address option in jail.conf
newmac = "$newmac = \"dd if=/dev/urandom bs=1024 count=1 2>/dev/null|md5|sed 's/^\\\\(..\\\\)\\\\(..\\\\)\\\\(..\\\\).*$/02\\\\:ff\\\\:c0\\\\:\\\\1:\\\\2:\\\\3/'\";"

# vnet
vnet = [
'### network settings ###',
'vnet;',
'vnet.interface = "epair${jid}b";',
newmac,
'exec.start = "ifconfig lo0 127.0.0.1/8";',
'exec.prestart = "ifconfig epair${jid} create";',
'exec.prestart += "$newmac |xargs ifconfig epair${jid}b ether";',
'exec.prestart += "ifconfig $bridge addm epair${jid}a up";',
'exec.prestart += "ifconfig epair${jid}a up";',
'exec.start += "ifconfig epair${jid}b $jip";',
'exec.start += "route add default $jgw";',
'exec.start += "/bin/sh /etc/rc";',
'exec.poststop = "ifconfig $bridge deletem epair${jid}a";',
'exec.poststop += "ifconfig epair${jid}a destroy";',
'exec.stop = "/bin/sh /etc/rc.shutdown";',
'exec.clean;',
'persist;'
]

# no vnet
net = [
'### network settings ###',
'ip4.addr = "$jip";',
'exec.start = "/bin/sh /etc/rc";',
'exec.stop = "/bin/sh /etc/rc.shutdown";',
'persist;',
]

########################################################################################
# Main Functions
########################################################################################

def load_jail_config(conf_f):
   """
########################################################################################
# load_jail_config - load default jail conf file and return a list with jail dictionary .
#  {'name':'jail name', 'host.hostname':'jail hostname', 'jid':'jail id', '$jip':'jail ip address ',
#  '$jgw':'jail gateway','path':'jail home dir', 'vnet':'is this vnet jail', 'zfs':'is thi zfs jail', ... }
#
   """
# open jail.conf
   jc = open(conf_f, 'r')

# take all elements from jail.conf, remove "junk" data and applay to mas[]
# only data which will be used is taken, all valuse are in order
   mas = []
   not_sorted_mas = []
   for i in jc:
      i = i.strip('\n')
      i = i.strip('\t')
# create raw list from file ony \n is removed
      not_sorted_mas.append(i)
      i = i.strip(';').replace('\"', '').replace(' ', '')
      i = i.split('=')
      mas.append(i)
   jc.close()

# find all jails names
   jsname = []
# enumerate in order to avoid wrong index for similiar items like {
# take only elements which are before { symbol
   for i, x in enumerate(mas):
      if "{" in x:
        jsname.append([mas[i - 1]])

# check active/dying jails
   caj = subprocess.check_output("jls -h jid", shell=True).strip('jid')
   caj = caj.split('\n')
   caj = cleanlist(caj)
# check for 'dying' jails
   caj_dying = subprocess.check_output("jls -d -h jid", shell=True).strip('jid')
   caj_dying = caj_dying.split('\n')
   caj_dying = cleanlist(caj_dying)

# find all jail.conf global settings (ignore # comments)
# search jail.conf from 0 line to first jail{} line
   global_settings = []
   gs_only = not_sorted_mas[0:mas.index(jsname[0][0])]

   for i in gs_only:
       if '#' in i:
           pass
       else:
# global seting line number
           x = not_sorted_mas.index(i)
# glabal setting table format
           i = i.strip(';').replace(' ', '')
           if i:
              global_settings.append([x, i])

# Jails Configuration in dict format.
   jails = []

   for i in jsname:
      jail_dict = {'name':i[0][0], 'host.hostname':'', 'jid':'', '$jip':'',
                   '$jgw':'','path':'', 'zfs':0}

      i = mas.index(i[0])
      jail_dict['jbegin'] = i

# Cehck jail index's (end and local_settigs)
      x = 0
      jail_local_settings_index = 0
      for z in mas[jail_dict['jbegin']:]:
         x = x + 1
# Find jail local settingss
         if z[0] == _Lsettings:
            jail_local_settings_index = jail_dict['jbegin'] + x

# Find jail end index
         if "}" in z:
            x -= 1
            jail_dict['jend'] = jail_dict['jbegin'] + x
            break

# add local settings index on firs place in list (us original jc[] )
      jlsettings_list = []
      i = jail_local_settings_index
      if i != 0:
         for x in not_sorted_mas[i : jail_dict['jend']]:
            i += 1
            if '#' in x:
               pass
            else:
# i is line number in jail.conf
               x = x.strip(';').replace(' ', '')
               if x:
                  jlsettings_list.append([i, x])

      jail_dict['local_settings'] = jlsettings_list

# All main jail settings
      for x in mas[jail_dict['jbegin']:jail_dict['jend']]:
         if x[0] in jail_dict.keys():
            jail_dict[x[0]] = x[1]

# is this a vnet jail ?
         if x[0] == 'vnet':
            jail_dict['vnet'] = 1

# do we have a bridge interface?
         if x[0] == '$bridge':
            jail_dict['$bridge'] = x[1]

# is this zfs jail ?
         if x[0] == 'path':
# if is SKEL jail will contain /mounts we don't need this
             jail_dict['path'] = jail_dict['path'].replace('/mounts', '')
             zfs_check = zfs(x[1])
             jail_dict['zfs'] = zfs_check[2]

# is this SKELETON MODEL jail
         if x[0] == 'mount.fstab':
            if '/rwdata/etc/fstab' in x[1]:
               jail_dict['SKEL'] = 1

# check if jail is active/inactive or dying
      if jail_dict['jid'] in caj:
         act = 1
      else:
         act = 0
         if jail_dict['jid'] in caj_dying:
            act = 'dying'
      jail_dict['active'] = act

# try to find jail path if we use global path with $name (jail name)
      if jail_dict['path'] == '':
         for x in global_settings:
               if 'path' in x[1]:
                  if '$name' in x[1]:
                     y = x[1].split('=')
                     fixpath = y[1][1:-6]
                     jail_dict['path'] = '%s%s' % (fixpath, jail_dict['name'])
                     zfs_check = zfs(jail_dict['path'])
                     jail_dict['zfs'] = zfs_check[2]

# end add this jail and go with the next one
      jails.append(jail_dict)

# return a list with all jails from jail.conf and list with all global settings
   return (jails, global_settings)

def zfs(zvalue = None):
   """
########################################################################################
# check if zvalue is in OS zfs list (mountpoint or zfs name)
# return (zfs names, zfs mountpoints,
#         zfs ( 0 if not exist) or [NAME,USED,AVAIL,REFER,MOUNTPOINT,QUOTA, SNAP_NUMBER])
#
   """
# check curent zfs pool
   zfs_name = subprocess.check_output("zfs list -H -o name", shell=True)
   zfs_name = zfs_name.split('\n')

   zfs_mountp = subprocess.check_output("zfs list -H -o mountpoint", shell=True)
   zfs_mountp = zfs_mountp.split('\n')

# default is False
   iszfs = 0
# cehck if iszfs exist
   if zvalue in zfs_name:
      return (zfs_name, zfs_mountp, 1)
# check if zvalue is in zfs(path or mountpoint)
   if zvalue in zfs_mountp:
# get zfs - NAME USED  AVAIL  REFER  MOUNTPOINT
      iszfs = subprocess.check_output("zfs list -H %s" % zvalue, shell=True)
      iszfs = iszfs.strip('\n').split('\t')
# get zfs quota
      iszfs_quota = subprocess.check_output("zfs get -H quota %s" % iszfs[0], shell=True)
      iszfs_quota = iszfs_quota.strip('\n').split('\t')
      iszfs.append(iszfs_quota[2])
# get numbet of snapshots
      zfs_snap = 0
      zfs_snap_search = iszfs[0]+'@'
      cmd = "zfs list -t snapshot |grep %s" %  (zfs_snap_search)
      try:
         for x in subprocess.check_output(cmd, shell=True).split('\n'):
            zfs_snap = zfs_snap + 1
         zfs_snap = zfs_snap - 1
      except:
         zfs_snap = 0
      iszfs.append(zfs_snap)

   return (zfs_name, zfs_mountp, iszfs)

def jail_table(mcmd):
   """
########################################################################################
# show all jails settings in tbale format
# show individual jail settings in table format
#
   """
   jails  = load_jail_config(jailconf)[0]

   jails_configs = []
   if len(mcmd) > 1:
       if mcmd[1] in ('ip', 'gw'):
           mcmd[1] = '$j' + mcmd[1]
       if mcmd[1] == 'hostname':
           mcmd[1] = 'host.hostname'

   if len(mcmd) == 3:
       for i in jails:
# list olny jails with quota / usage >= from user search
          if i['zfs'] != 0:
              if mcmd[1] == 'quota':
                  if mcmd[2][-1] not in ('K', 'M', 'G', 'T', 'P', 'E'):
                     return False
                  jquota = float(i['zfs'][5][:-1])
                  jquota = bytesto(jquota, i['zfs'][5][-1])
                  search_quota = float(mcmd[2][:-1])
                  search_quota = bytesto(search_quota, mcmd[2][-1])
                  if int(jquota) >= int(search_quota):
                    jails_configs.append(i)

              elif mcmd[1] == 'used':
                  if mcmd[2][-1] not in ('K', 'M', 'G', 'T', 'P', 'E'):
                     return False
                  jused = float(i['zfs'][1][:-1])
                  jused = bytesto(jused, i['zfs'][1][-1])
                  search_used = float(mcmd[2][:-1])
                  search_used = bytesto(search_used, mcmd[2][-1])
                  if int(jused) >= int(search_used):
                     jails_configs.append(i)
# find all other jail settings
          if mcmd[1] not in i.keys():
              pass
          elif mcmd[2] in i[mcmd[1]]:
              jails_configs.append(i)

          jails = jails_configs

   if len(mcmd) == 2:
       for i in jails:
           if mcmd[1] == 'active':
               if i['active'] == 1:
                  jails_configs.append(i)
           elif mcmd[1] == 'inactive':
               if i['active'] == 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'dying':
               if i['active'] == 'dying':
                  jails_configs.append(i)
           elif mcmd[1] == i['name']:
               jails_configs.append(i)
           elif mcmd[1] == i['jid']:
               jails_configs.append(i)
           elif mcmd[1] == 'zfs':
               if i['zfs'] != 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'nozfs':
               if i['zfs'] == 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'skel':
               if 'SKEL' in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'noskel':
               if 'SKEL' not in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'vnet':
               if 'vnet' in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'novnet':
               if 'vnet' not in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'empty':
               if '' in i.values():
                  jails_configs.append(i)
           jails = jails_configs

   if len(jails) == 0:
       return False

# create a jails table list
   jlist = []
   for i in jails:
       jail_temp_list = []
       jail_temp_list.append('')
       if 'SKEL' in i.keys():
           jail_temp_list[0] =  jail_temp_list[0] + 'S'
       if 'vnet' in i.keys():
           jail_temp_list[0] =  jail_temp_list[0] + 'V'
       jail_temp_list.append(i['active'])
       jail_temp_list.append(i['jid'])
       jail_temp_list.append(i['name'])
       jail_temp_list.append(i['host.hostname'])
       jail_temp_list.append(i['$jip'])
       jail_temp_list.append(i['$jgw'])
       jail_temp_list.append(i['path'])
       if i['zfs'] != 0:
          jail_temp_list[0] =  jail_temp_list[0] + 'Z'
          jail_temp_list.append('%s/%s' % (i['zfs'][1], i['zfs'][2]))
          jail_temp_list.append(i['zfs'][-2])
          jail_temp_list.append(i['zfs'][-1])
       else:
          jail_temp_list.append('n/a')
          jail_temp_list.append('n/a')
          jail_temp_list.append('n/a')
       if i['active'] == 'dying':
          jail_temp_list[0] = jail_temp_list[0] + '_DYING'

       if mcmd[0] == 'jls':
           jail_temp_list = jail_temp_list[:6]
       jlist.append(jail_temp_list)

# table menu
   lmen = ["FLAGS", "ACTIVE", "JID", "NAME", "HOSTNAME", "IP ADDRESS", "GATEWAY", "PATH", "USED/AVAIL SPACE", "ZQUOTA",  "ZSNAP"]
# check if we use short list - jls
   if mcmd[0] == 'jls':
       lmen = ["FLAGS", "ACTIVE", "JID", "NAME", "HOSTNAME", "IP ADDRESS"]

   print tabulate(jlist, lmen)

def bytesto(bytes, to, bsize=1024):
   """
########################################################################################
# convert bytes to megabytes, etc.
# sample code:
# print('mb= ' + str(bytesto(314575262000000, 'm')))
#
# sample output:
# mb= 300002347.946
# from: https://gist.github.com/shawnbutts/3906915
   """

   a = {'K' : 1, 'M': 2, 'G' : 3, 'T' : 4, 'P' : 5, 'E' : 6 }
   r = float(bytes)
   for i in range(a[to]):
      r = r * bsize

   return(r)

def cleanlist(list):
   """
########################################################################################
# remove all empty '' elements from list
#
   """
   list = [x for x in list if x]
   return list

def ch_ipv4(sp):
    """
########################################################################################
# This function check if ip address fromat sp var is correct
# numbers of octet should be 4, each octet separated by '.' should be less than 256
#
    """
    octet = sp.split('.')
    if len(octet) != 4:
       return False
    try:
       return all(0<=int(p)<256 for p in octet)
    except ValueError:
       return False

def gateways(gwtable = None):
   """
########################################################################################
# find and display in table format existing bridge interfacess in system
#
   """

   bridges = []
   bridge_dict = {'name':'', 'addr':''}
# find all bridegX interfaces
   for i in netifaces.interfaces():
      if 'bridge' in i:
# fill all lists for bridge
         bridge_dict['addr'] = netifaces.ifaddresses(i)[netifaces.AF_INET]
         for x in bridge_dict['addr']:
            bridges.append({'name':i, 'addr':x})

# append os system default gateway
   system = subprocess.check_output('route get default', shell=True)
   system = system.split('\n')
   for i in system:
      i = i.split(':')
      if 'gateway' in i[0]:
         bridges.append({'name':'system', 'addr':{'addr':i[1].replace(' ', ''), 'broadcast':'', 'netmask':'' }})

# make final list TO BE FIXED
   gwlist = []
   gwname = 'n/a'
   for i in  bridges:
      if i['name'] == gwname:
          i['name'] = ' '
      gwlist.append([i['name'], i['addr']['addr'], i['addr']['netmask'], i['addr']['broadcast']])

# show gateway table
   if gwtable != None:
      lmen = ['INTERFACE', 'ADDRESS', 'NETWORKMASK', 'BROADCAST']
      print tabulate(gwlist, lmen)      

# return bridge interface name, ip addresses and network mask
   return (bridges)

def bridge_network_check(ip, bridge_ip, bridge_netmask):
   """
########################################################################################
# check if ipaddress is in selected bridge network
#
   """
# convert vars to unicode
   ip = unicode(ip)
   bridge_ip = unicode(bridge_ip)
   bridge_netmask = unicode(bridge_netmask)
# by default ip is not in bridge network
   brctl = 0

# bridge insterface ip network
   brdige_network = IPv4Interface('%s/%s' % (bridge_ip, bridge_netmask)).network

# check if ip is from bridge network and return bridge control var (brctl) = true
   if IPv4Address(ip) in list(IPv4Network(brdige_network)):
      brctl = 1

# return brctl and bridge ip network
   return brctl

def globals(action = None, setting = None):
   """
########################################################################################
#  manipulate jail global options list, remove or add new option
#
   """
   jail_config = load_jail_config(jailconf)
   jails, gsettings = jail_config[0], jail_config[1]
# create globals list  
   num = 0
   gs = []
   for i in gsettings:
      gs.append([num, i[1]])
      num += 1

   lmen = ["GLOBALS SETTINGS"]
# show globals
   if action == None:
      print tabulate(gs, lmen)

# add new global setting
   elif action == 'add':
       if setting != None:
          if gsettings == []:
              gs_position = 0
          else:
              gs_position = gsettings[-1][0]
          update_jail_conf(['insert_line', [gs_position, '%s;' % setting]])
          log(0, "'%s' global setting was added!" % setting, 1)

# remove existing global setting
   elif action == 'remove':
      try:
         rmset = gsettings.pop(int(setting))
         update_jail_conf(['rm_line', [rmset[0]]])
         log(1, "'%s' glabal setting was removed!" % rmset[1])
      except:
         print tabulate(gs, lmen)
         log(2, "'%s' is not a global setting number!" % setting, 1)
         return False
   else:
      log(2, "Please enter 'help globals' for valid commands!")

def locals(j = None, action = None, setting = None):
   """
########################################################################################
#  manipulate jail locals options list, remove or add new option
#
   """
   jails = load_jail_config(jailconf)[0]

# find jail by id or name
   jail = None
   for i in jails:
      if str(i['name']) == str(j):
         jail = i
         break
      if str(i['jid']) == str(j):
         jail = i
         break
   if jail == None:
      log(2, "'%s' was not found in jails!" % j)
      return False

# create jail locals list
   num = 0
   ls = []
   for i in jail['local_settings']:
      ls.append([num, i[1]])
      num += 1

   lmen = ["'%s' LOCALS SETTINGS" % jail['name']]

# list jail local settings
   if action == None:
      if ls == []:
        log(0, "'%s' jail doesn't have locals settings!" % (jail['name']))
      else:
         print tabulate(ls, lmen)

# add new jail local setting
   elif action == 'add':
       if setting != None:
          if jail['local_settings'] == []:
              ls_position = jail['jend']
          else:
              ls_position = jail['local_settings'][-1][0]
          update_jail_conf(['insert_line', [ls_position, '%s;' % setting]])
          log(0, "'%s' local setting was added to '%s' jail!" % (setting, jail['name']), 1)

# remove existing jail local setting
   elif action == 'remove':
      try:
         rmset = jail['local_settings'].pop(int(setting))
         update_jail_conf(['rm_line', [rmset[0] - 1]])
         log(1, "'%s' local setting was removed from '%s' jail!" % (rmset[1], jail['name']), 1)
      except:
         print tabulate(ls, lmen)
         log(2, "'%s' is not a '%s' jail local setting number!" % (setting, jail['name']))
         return False
   else:
      log(2, "Please enter 'help locals' for valid commands!")


def update_jail_conf(update):
########################################################################################
# update jail.conf
#

# open jail.conf
   jc = open(jailconf, 'r')
   jcl = []
   for i in jc:
      i = i.strip('\n')
      jcl.append(i)
   jc.close()

   if update[0] == 'insert_line':
      jcl.insert(update[1][0], update[1][1])

   if update[0] == 'rm_line':
      del jcl[update[1][0]]

# close jail.conf
   jc = open(jailconf, 'w')
   jc.write('\n'.join(jcl))
   jc.close()

 
def log(ltype, msg, logit = None):
   """
########################################################################################
# print msg and log it if is needed
# log([0 - INFO, 1 = WARRNING and 2 - ERROR], 'log message', 'eny value if you want
#      to log in jailog file'
#
   """

   logtype = ['INFO', 'WARNING', 'ERROR']
   print "	%s: %s" % (logtype[ltype], msg)

   if logit != None:
      logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s', level=logging.DEBUG, filename=logfile)
      if ltype == 0:
         logging.info('   %s' % msg)
      if ltype == 1:
         logging.warning(msg)
      if ltype == 2:
         logging.error('  %s' % msg)

def jail_input(modify = None):
   """
########################################################################################
# create new jail or modify existing jail (settings input)
#
   """
   load_jails = load_jail_config(jailconf)
   jails, gsettings = load_jails[0], load_jails[1]

   if modify == None:
      prompt = ':> '
      acText = 'Create New'
      input_keys = ['name', 'id', 'hostname','vnet', 'ip', 'zfs', 'path', 'install src']
   else:
      acText = 'Modify'
      input_keys = ['name', 'id', 'hostname','vnet', 'ip', 'zfs', 'path']

   new_jail = {'name':'', 'host.hostname':'', 'jid':'', '$jip':'',
               '$jgw':'','path':'', 'zfs':0, }

   print "----------------------------------------------------"
   print "                %s Jail " % acText
   print "----------------------------------------------------"

   for ikey in input_keys:
       while True:

# choose install source - only for new jail
           if ikey == 'install src':
             print ""
             print tabulate([['template', 'existing jail for template' ], ['bsd',  'bdsinstaller'],  ['src', 'bsd pre compiled sources /usr/src/' ],
                            ["skel", "jail skeleton model"]], ['Install Source',  'Description'])

           if ikey in ['vnet', 'zfs']:
              ekey = raw_input("is %s jail (y) %s" % (ikey, prompt))
           else:
              ekey = raw_input('enter jail %s %s' % (ikey, prompt))

# enter jail name
           if ikey == 'name':
              if check_jail_Setting(ikey, ekey) == False:
                 continue
              else:
                 new_jail['name'] = ekey
                 break
# enter jail id
           if ikey == 'id':
              if check_jail_Setting(ikey, ekey) == False:
                 continue
              else:
                 new_jail['jid'] = str(ekey)
                 break
# enter jail hostname
           if ikey == 'hostname':
              if check_jail_Setting(ikey, ekey) == False:
                 continue
              else:
                 new_jail['host.hostname'] = ekey
                 break
# enter jail vnet gateway or be system
           if ikey == 'vnet':
              if 'y' in ekey:
                 while True:
                    print ''
                    gws = gateways('table')
                    egw = raw_input("enter jail gateway %s" % prompt)
# check if entered gw exist
                    find_gw = check_jail_Setting(ikey, [egw, gws])
                    if find_gw == False:
                       continue
                    else:
                       new_jail['$jgw'] = find_gw[0]
                       new_jail['$bridge'] = find_gw[1]
                       new_jail['gwnetmask']= find_gw[2]
                       new_jail['vnet'] = 1
                       break
                 break
              else:
                 new_jail['vnet'] = 0
                 new_jail['$jgw'] = 'system'
                 new_jail['gwnetmask'] = ''
                 break
# enter ip address already 
           if ikey == 'ip':
              if check_jail_Setting(ikey, [ekey, new_jail]) == False:
                 continue
              else:
                 new_jail['$jip'] = ekey
                 break
# create zfs if is needed
           if ikey == 'zfs':
              if 'y' in ekey:
                 while True:
                    ezfs = raw_input("enter zfs root %s" % prompt)
# try to use global setting path as zfs:
                    if ezfs == '':
                       for x in gsettings:
                          if 'path' in x[1]:
                             if '$name' in x[1]:
                                y = x[1].split('=')
                                ezfs = y[1][2:-7]
                                log(0, "global path found - '%s' will be used!" % ezfs)
                    if ezfs == '':
                       break
                    ezfs_check = check_jail_Setting(ikey, ezfs)
                    if ezfs_check == False:
                       continue
                    else:
                       new_jail['zfs'] = ['%s/%s' % (ezfs, new_jail['name'])]
# use zfs quota -----------
                       while True:
                          zquota = raw_input("enter zfs quota %s" % prompt)
                          if  zquota in ['\n', '', ' ', '	']:
                             new_jail['zfs'].append('none')
                             break
                          if  check_jail_Setting('zquota', zquota) == False:
                             continue
                          else:
                             new_jail['zfs'].append(zquota)
                             break
# use zfs quota -----------
                       break
              break
# enter jail path
           if ikey == 'path':
# try to use global setting path as zfs:
              if ekey == '':
                       for x in gsettings:
                          if 'path' in x[1]:
                             if '$name' in x[1]:
                                y = x[1].split('=')
                                ekey = '%s%s' % (y[1][1:-6], new_jail['name'])
                                log(0, "global path found - '%s' will be used!" % ekey)
              if ekey == '':
                 log(2, " not valid path!")
                 continue
              if check_jail_Setting(ikey, ekey) == False:
                 continue
              else:
                 if '/' != ekey[0]:
                     log(2, "'%s' is not valid path!" % ekey)
                     continue
                 new_jail['path'] = ekey
                 if new_jail['zfs'] != 0:
                    new_jail['zfs'].append(ekey)
                 break

# choose install source - only for new jail
           if ikey == 'install src':
             if check_jail_Setting(ikey, ekey) == False:
                 continue
             else:
                 new_jail['install'] = [ekey]
                 break

   print new_jail
   print jails

def check_jail_Setting(setting, val):
   """
########################################################################################
# check if we can use 'val' for jail 'settings'
#
   """

   load_jails = load_jail_config(jailconf)
   jails, gsettings = load_jails[0], load_jails[1]

# check if we can use name = val
   if setting == 'name':
      exist = []
      for j in jails:
         exist.append (j['name'])
      if val in exist:
         log(2, "Jail with %s '%s' already exist!" % (setting, val))
         return False

# check if we can use id = val
   if setting == 'id':
      try:
         int(val)
         if val == '0':
            log(2, "'%s' is not a valid jail id number!" % (val))
            return False
      except:
         log(2, "'%s' is not a valid jail id number!" % (val))
         return False
      exist = []
      for j in jails:
         exist.append (j['jid'])
         if val in exist:
            log(2, "Jail with %s '%s' already exist!" % (setting, val))
            return False

# cehck if we can use hostname = val
   if setting == 'hostname':
       exist = []
       for j in jails:
          exist.append (j['host.hostname'])
       if val in exist:
          log(2, "Jail with %s '%s' already exist!" % (setting, val))
          return False

# cehck vnet = val and return gateway
   if setting == 'vnet':
       if ch_ipv4(val[0]) == False:
          log(2, "'%s' is not a valid gateway ip address!" % (val[0]))
          return False
       for j in val[1]:
          gaddr = j['addr']
          if val[0] == gaddr['addr']:
              return (gaddr['addr'], j['name'], gaddr['netmask'])
       log(2, "'%s' is not a valid gateway ip address!" % (val[0]))
       return False

# check if tshi ip is aveilable
# val[0] - ip, vla[1] new_jail{}
   if setting == 'ip':
      if ch_ipv4(val[0]) == False:
            log(2, "'%s' is not a valid ip address!" % (val[0]))
            return False
      if val[1]['$jgw'] != 'system':
         if bridge_network_check(val[0], val[1]['$jgw'], val[1]['gwnetmask']) == False:
            log(2, "'%s' is not a part from %s/%s network!" % (val[0], val[1]['$jgw'], val[1][ 'gwnetmask']))
            return False
         for j in jails:
            if val[1]['$jip'] == j['$jip'][:-3]:
               log(2, "'%s' ip address is used by '%s' jail!" % (val[0], j['name']))
               return False
# check jail zfs root -----------------
   if setting == 'zfs':
# get/create zfs 
      if zfs(val)[2] != 1:
         log(2, "'%s' zfs root not exist!" % val)
         zfs_y = raw_input('create it now (y)?> ')
         if 'y' in zfs_y:
            try:
               subprocess.check_call('zfs create %s' % val, shell=True)
               subprocess.check_call('zfs set mountpoint=none  %s' % val, shell=True)
               log(0, "jail zfs root '%s' was created!" % val, 1)
               return val
            except subprocess.CalledProcessError:
               log(2, "'%s' cannot be created!" % val, 1)
               return False
         else:
            return False
# check zfs quota
   if setting == 'zquota':
      if val[-1] in ('K', 'M', 'G', 'T', 'P', 'E'):
         try:
            int(zquota[:-1])
            return True
         except:
            pass
      else:
         log(2, "'%s' is not correct zfs quota format!  xxx('K', 'M', 'G', 'T', 'P', 'E') " % val)
         return False
# check is we can use path = val
   if setting == 'path':
       if zfs(val)[2] == 1:
         log(2, "'%s' already exist zfs path!" % val)
         return False

       if os.path.isdir(val) == True:
         log(2, "'%s' already exist!" % val)
         return False
# check install source
   if setting == 'install src':
       install_src = ['bsd', 'template', 'skel', 'src']
       if val not in install_src:
          log(2, "enter only  %s!" % install_src)
          return False

########################################################################################
# MAIN MENU
########################################################################################

class lcmd(cmd.Cmd):
   """
########################################################################################
#  interactive main menu with 'cmd' function
#
   """
   prompt = 'jadm:> '

   local_global = ['remove',  'add']
   snap = ['list', 'create',  'remove',  'restore']
   listcmd = ['list', 'hostname',  'ip',  'gw',
              'active',  'inactive', 'dying',
              'vnet', 'novnet', 'zfs', 'nozfs',
              'skel', 'noskel', 'quota', 'used', 'empty']
   mserver = ['server',  'client']

   def do_list(self, arg):
      """ List of jails in table format
      - FLAGS
      S - skeleton model jail
      V - vnet jail
      Z - zfs jail
      _DYING - dying jail

      - usage: list

      (search options)
      - only actvie jails (usage: list active)
      - only inactive jails (usage: list inactive)
      - only dying jails (usage: list dying)
      - no fully configured jails (usage: list empty)
      - by name (usage: list 'name/jid' )
      - by hostname (usage: list hostname 'jail hostname' )
      - by path (usage: lisy path '/jail/home/path' )
      - by ipaddress (usage: list ip 'ipaddress' )
      - by gateway (usage: list gw 'gateway ip' )
      - only vnet jails (usage: list vnet )
      - only none vnet jails (usage: list novnet )
      - only skel jails (usage: list skel )
      - only none skel jails (usage: list noskel )
      - only none zfs jails (usage list nozfs)
      --- apply only on zfs jails ---
      - only zfs jails (usage: list zfs)
      - by zfs quota (usage: list quota 'xxx('K', 'M', 'G', 'T', 'P', 'E')')
      show jails with quota = or > form x number
      - by zfs used space (usage: list used xxx('K', 'M', 'G', 'T', 'P', 'E')')
      show jails with used space = or > form x number
      """
      arg = str(arg).split(' ')

      if arg[0] != '':
         arg.insert(0,'list')
         arg = [i for i in arg if i != '']

      jail_table(arg)

   def complete_list(self, text, line, begidx, endidx):
      if not text:
         completions = self.listcmd[:]
      else:
         completions = [ f for f in self.listcmd if f.startswith(text)]
         return completions

   def do_jls(self,  arg):
      """ Short list of jails in table format
      - FLAGS
      S - skeleton model jail
      V - vnet jail
      Z - zfs jail
      _DYING - jails is dying

      - usage: jls

        same as list (show jails table in short format)
      """
      arg = str(arg).split(' ')
      arg.insert(0,'jls')
      arg = [i for i in arg if i != '']

      jail_table(arg)

   def complete_jls(self, text, line, begidx, endidx):
      if not text:
         completions = self.listcmd[:]
      else:
         completions = [ f for f in self.listcmd if f.startswith(text)]
         return completions

   def do_gateways(self,  arg):
      """ Show system 'bridgeX' interfaces 
          used for jail gateways and OS (system) default gateway 
      """

      gateways(gwtable = 1)
      
   def do_globals(self,  arg):
      """Globals settings
        - list of globals settings (usage: globals)
        - remove global setting (usage: globals remove 'setting number' )
        - add global setting (usage: globals add 'setting=val')
      """

      arg = str(arg).split(' ')
      arg = [i for i in arg if i != '']
 
      if len(arg) > 1:     
         globals(arg[0], arg[1])
      else:
         globals()

   def complete_globals(self, text, line, begidx, endidx):
      if not text:
         completions = self.local_global[:]
      else:
         completions = [ f for f in self.local_global if f.startswith(text)]
         return completions

   def do_locals(self,  arg):
      """Jails Locals settings
        - list of jail locals settings (usage: locals 'name/jid')
        - remove jail local setting (usage: locals 'name/jid' remove 'setting number' )
        - add jail local setting (usage: locals 'name/jid' add 'setting=val')
      """

      arg = str(arg).split(' ')
      arg = [i for i in arg if i != '']

      if len(arg) == 3:
         locals(arg[0], arg[1], arg[2])
      elif len(arg) == 1:
         locals(arg[0])
      else:
         log(2, "Please enter 'help locals' for valid commands!")

   def complete_locals(self, text, line, begidx, endidx):
      if not text:
         completions = self.local_global[:]
      else:
         completions = [ f for f in self.local_global if f.startswith(text)]
         return completions

def cli():
   """
########################################################################################
#  jadm command line interface
#
   """
   if sys.argv[1] in ['-y', '-v', '-c', '-m', '-i']:

# cli verbose mode for start/stop jail
         if sys.argv[1] == '-v':
            verbose = 1
            # prtin and add to log file
            logmsg = "      INFO: verbose mode enable"
            log(logmsg)

# cli auto confirm

         if '-y' in sys.argv:
            sys.argv[ sys.argv.index('-y')] = 'autoConfirm:yes'
         else:
             sys.argv.append('autoConfirm:no')

# cli create jail
         if sys.argv[1] == '-c':
            jail_create_cli(sys.argv)
            sys.exit(0)

# cli modify jail
         if sys.argv[1] == '-m':
            print "jadm cli modify"
            sys.exit(0)


# cli jail - os info
         if sys.argv[1] == '-i':
            welcome()
            sys.exit(0)

         jadmCommand = ' '.join(sys.argv[2:])
   else:
      jadmCommand = ' '.join(sys.argv[1:])

# cli command
   lcmd().onecmd(jadmCommand)

########################################################################################
# Start Jadm script
########################################################################################

jail_input()

if len(sys.argv) > 1:
# use cli interface
   cli()
else:
# main menu shell
   lcmd().cmdloop()

########################################################################################
# End Jadm script
########################################################################################
