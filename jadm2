#!/usr/bin/env python
########################################################################################
# Jadm license information
#
'''
Copyright (c) <2015>, <Nikolay Georgiev Dachev> <nikolay@dachev.info>
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'''
########################################################################################
# Python modules
# datetime - used for current date/time on event
# tabulate - used to print useful infomration in table format
# os, sys, subprocess - used for comunication with FreeBSD
# netifaces - used for check FreeBSD bridge interfaces
# ipaddress - used to check if jail ip is from gateway network
# cmd - used for jadm command shell
# paramiko - used for jail migration via ssh
# socket - jadm client/server
# AES - aes encryption
# base64 aes encription help

from datetime import datetime
from tabulate import tabulate
from ipaddress import *
import sys
import logging
import subprocess
import netifaces
import cmd
import paramiko
import socket
from Crypto.Cipher import AES
import base64

########################################################################################
# Main config vars:
########################################################################################

# jadm version
jadm_version = "ver. 2.0"

# jail.conf location by default /etc/jail.conf
jailconf = '/etc/jail.conf'

# jadm log file
logfile = '/var/log/jadm.log'

# jadm don't show verbose output by defult
verbose = 0

# settings start index in jail.conf
_Lsettings = '#@#localsettings#@#'

# jadm server
LHOST = '0.0.0.0'
LPORT = 4555

# network config
# newmac generate random mac address option in jail.conf
newmac = "$newmac = \"dd if=/dev/urandom bs=1024 count=1 2>/dev/null|md5|sed 's/^\\\\(..\\\\)\\\\(..\\\\)\\\\(..\\\\).*$/02\\\\:ff\\\\:c0\\\\:\\\\1:\\\\2:\\\\3/'\";"

# vnet
vnet = [
'### network settings ###',
'vnet;',
'vnet.interface = "epair${jid}b";',
newmac,
'exec.start = "ifconfig lo0 127.0.0.1/8";',
'exec.prestart = "ifconfig epair${jid} create";',
'exec.prestart += "$newmac |xargs ifconfig epair${jid}b ether";',
'exec.prestart += "ifconfig $bridge addm epair${jid}a up";',
'exec.prestart += "ifconfig epair${jid}a up";',
'exec.start += "ifconfig epair${jid}b $jip";',
'exec.start += "route add default $jgw";',
'exec.start += "/bin/sh /etc/rc";',
'exec.poststop = "ifconfig $bridge deletem epair${jid}a";',
'exec.poststop += "ifconfig epair${jid}a destroy";',
'exec.stop = "/bin/sh /etc/rc.shutdown";',
'exec.clean;',
'persist;'
]

# no vnet
net = [
'### network settings ###',
'ip4.addr = "$jip";',
'exec.start = "/bin/sh /etc/rc";',
'exec.stop = "/bin/sh /etc/rc.shutdown";',
'persist;',
]

########################################################################################
# Main Functions
########################################################################################

def load_jail_config(conf_f):
   """
########################################################################################
# load_jail_config - load default jail conf file and return a list with jail dictionary .
#  {'name':'jail name', 'host.hostname':'jail hostname', 'jid':'jail id', '$jip':'jail ip address ',
#  '$jgw':'jail gateway','path':'jail home dir', 'vnet':'is this vnet jail', 'zfs':'is thi zfs jail', ... }
#
   """
# open jail.conf
   jc = open(conf_f, 'r')

# take all elements from jail.conf, remove "junk" data and applay to mas[]
# only data which will be used is taken, all valuse are in order
   mas = []
   not_sorted_mas = []
   for i in jc:
      i = i.strip('\n')
      i = i.strip('\t')
# create raw list from file ony \n is removed
      not_sorted_mas.append(i)
      i = i.strip(';').replace('\"', '').replace(' ', '')
      i = i.split('=')
      mas.append(i)
   jc.close()

# find all jails names
   jsname = []
# enumerate in order to avoid wrong index for similiar items like {
# take only elements which are before { symbol
   for i, x in enumerate(mas):
      if "{" in x:
        jsname.append([mas[i - 1]])

# check active/dying jails
   caj = subprocess.check_output("jls -h jid", shell=True).strip('jid')
   caj = caj.split('\n')
   caj = cleanlist(caj)
# check for 'dying' jails
   caj_dying = subprocess.check_output("jls -d -h jid", shell=True).strip('jid')
   caj_dying = caj_dying.split('\n')
   caj_dying = cleanlist(caj_dying)

# find all jail.conf global settings (ignore # comments)
# search jail.conf from 0 line to first jail{} line
   global_settings = []
   gs_only = not_sorted_mas[0:mas.index(jsname[0][0])]
   for i in gs_only:
       if '#' in i:
           pass
       else:
# global seting line number
           x = not_sorted_mas.index(i) + 1
# glabal setting table format
           i = i.strip(';').replace(' ', '')
           if i:
              global_settings.append([x, i])

# Jails Configuration in dict format.
   jails = []

   for i in jsname:
      jail_dict = {'name':i[0][0], 'host.hostname':'', 'jid':'', '$jip':'',
                   '$jgw':'','path':'', 'zfs':0}

      i = mas.index(i[0])
      jail_dict['jbegin'] = i

# Cehck jail index's (end and local_settigs)
      x = 0
      jail_local_settings_index = 0
      for z in mas[jail_dict['jbegin']:]:
         x = x + 1
# Find jail local settingss
         if z[0] == _Lsettings:
            jail_local_settings_index = jail_dict['jbegin'] + x

# Find jail end index
         if "}" in z:
            x -= 1
            jail_dict['jend'] = jail_dict['jbegin'] + x
            break

# add local settings index on firs place in list (us original jc[] )
      jlsettings_list = []

      for x in not_sorted_mas[jail_local_settings_index : jail_dict['jend']]:
# i is line number in jail.conf
          i = not_sorted_mas.index(x) + 2
          x = x.strip(';').replace(' ', '')
          jlsettings_list.append([i, x])
      jail_dict['local_settings'] = jlsettings_list

# All main jail settings
      for x in mas[jail_dict['jbegin']:jail_dict['jend']]:
         if x[0] in jail_dict.keys():
            jail_dict[x[0]] = x[1]

# is this a vnet jail ?
         if x[0] == 'vnet':
            jail_dict['vnet'] = 1

# do we have a bridge interface?
         if x[0] == '$bridge':
            jail_dict['$bridge'] = x[1]

# is this zfs jail ?
         if x[0] == 'path':
# if is SKEL jail will contain /mounts we don't need this
             jail_dict['path'] = jail_dict['path'].replace('/mounts', '')
             zfs_check = zfs(x[1])
             jail_dict['zfs'] = zfs_check[2]

# is this SKELETON MODEL jail
         if x[0] == 'mount.fstab':
            if '/rwdata/etc/fstab' in x[1]:
               jail_dict['SKEL'] = 1

# check if jail is active/inactive or dying
      if jail_dict['jid'] in caj:
         act = 1
      else:
         act = 0
         if jail_dict['jid'] in caj_dying:
            act = 'dying'
      jail_dict['active'] = act

# try to find jail path if we use global path with $name (jail name)
      if jail_dict['path'] == '':
         for gs in global_settings:
            gs = gs.split('=')
            if gs[0] == 'path':
                if '$name' in gs[1]:
                    fixpath = gs[1][1:-6]
                    jail_dict['path'] = '%s%s' % (fixpath, jail_dict['name'])
                    zfs_check = zfs(jail_dict['path'])
                    jail_dict['zfs'] = zfs_check[2]

# end add this jail and go with the next one
      jails.append(jail_dict)

# return a list with all jails from jail.conf and list with all global settings
   return (jails, global_settings)

def zfs(zvalue = None):
   """
########################################################################################
# check if zvalue is in OS zfs list (mountpoint or zfs name)
# return (zfs names, zfs mountpoints,
#         zfs ( 0 if not exist) or [NAME,USED,AVAIL,REFER,MOUNTPOINT,QUOTA, SNAP_NUMBER])
#
   """
# check curent zfs pool
   zfs_name = subprocess.check_output("zfs list -H -o name", shell=True)
   zfs_name = zfs_name.split('\n')

   zfs_mountp = subprocess.check_output("zfs list -H -o mountpoint", shell=True)
   zfs_mountp = zfs_mountp.split('\n')

# check if zvalue is in zfs(path or mountpoint)
   iszfs = 0
   if zvalue in zfs_mountp:
# get zfs - NAME USED  AVAIL  REFER  MOUNTPOINT
      iszfs = subprocess.check_output("zfs list -H %s" % zvalue, shell=True)
      iszfs = iszfs.strip('\n').split('\t')
# get zfs quota
      iszfs_quota = subprocess.check_output("zfs get -H quota %s" % iszfs[0], shell=True)
      iszfs_quota = iszfs_quota.strip('\n').split('\t')
      iszfs.append(iszfs_quota[2])
# get numbet of snapshots
      zfs_snap = 0
      zfs_snap_search = iszfs[0]+'@'
      cmd = "zfs list -t snapshot |grep %s" %  (zfs_snap_search)
      try:
         for x in subprocess.check_output(cmd, shell=True).split('\n'):
            zfs_snap = zfs_snap + 1
         zfs_snap = zfs_snap - 1
      except:
         zfs_snap = 0
      iszfs.append(zfs_snap)

   return (zfs_name, zfs_mountp, iszfs)

def jail_table(mcmd):
   """
########################################################################################
# show all jails settings in tbale format
# show individual jail settings in table format
#
   """
   jails  = load_jail_config(jailconf)[0]

   jails_configs = []
   if len(mcmd) > 1:
       if mcmd[1] in ('ip', 'gw'):
           mcmd[1] = '$j' + mcmd[1]
       if mcmd[1] == 'hostname':
           mcmd[1] = 'host.hostname'

   if len(mcmd) == 3:
       for i in jails:
# list olny jails with quota / usage >= from user search
          if i['zfs'] != 0:
              if mcmd[1] == 'quota':
                  if mcmd[2][-1] not in ('K', 'M', 'G', 'T', 'P', 'E'):
                     return False
                  jquota = float(i['zfs'][5][:-1])
                  jquota = bytesto(jquota, i['zfs'][5][-1])
                  search_quota = float(mcmd[2][:-1])
                  search_quota = bytesto(search_quota, mcmd[2][-1])
                  if int(jquota) >= int(search_quota):
                    jails_configs.append(i)

              elif mcmd[1] == 'used':
                  if mcmd[2][-1] not in ('K', 'M', 'G', 'T', 'P', 'E'):
                     return False
                  jused = float(i['zfs'][1][:-1])
                  jused = bytesto(jused, i['zfs'][1][-1])
                  search_used = float(mcmd[2][:-1])
                  search_used = bytesto(search_used, mcmd[2][-1])
                  if int(jused) >= int(search_used):
                     jails_configs.append(i)
# find all other jail settings
          if mcmd[1] not in i.keys():
              pass
          elif mcmd[2] in i[mcmd[1]]:
              jails_configs.append(i)

          jails = jails_configs

   if len(mcmd) == 2:
       for i in jails:
           if mcmd[1] == 'active':
               if i['active'] == 1:
                  jails_configs.append(i)
           elif mcmd[1] == 'inactive':
               if i['active'] == 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'dying':
               if i['active'] == 'dying':
                  jails_configs.append(i)
           elif mcmd[1] == i['name']:
               jails_configs.append(i)
           elif mcmd[1] == i['jid']:
               jails_configs.append(i)
           elif mcmd[1] == 'zfs':
               if i['zfs'] != 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'nozfs':
               if i['zfs'] == 0:
                  jails_configs.append(i)
           elif mcmd[1] == 'skel':
               if 'SKEL' in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'noskel':
               if 'SKEL' not in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'vnet':
               if 'vnet' in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'novnet':
               if 'vnet' not in i.keys():
                  jails_configs.append(i)
           elif mcmd[1] == 'empty':
               if '' in i.values():
                  jails_configs.append(i)
           jails = jails_configs

   if len(jails) == 0:
       return False

# create a jails table list
   jlist = []
   for i in jails:
       jail_temp_list = []
       jail_temp_list.append('')
       if 'SKEL' in i.keys():
           jail_temp_list[0] =  jail_temp_list[0] + 'S'
       if 'vnet' in i.keys():
           jail_temp_list[0] =  jail_temp_list[0] + 'V'
       jail_temp_list.append(i['active'])
       jail_temp_list.append(i['jid'])
       jail_temp_list.append(i['name'])
       jail_temp_list.append(i['host.hostname'])
       jail_temp_list.append(i['$jip'])
       jail_temp_list.append(i['$jgw'])
       jail_temp_list.append(i['path'])
       if i['zfs'] != 0:
          jail_temp_list[0] =  jail_temp_list[0] + 'Z'
          jail_temp_list.append('%s/%s' % (i['zfs'][1], i['zfs'][2]))
          jail_temp_list.append(i['zfs'][-2])
          jail_temp_list.append(i['zfs'][-1])
       else:
          jail_temp_list.append('n/a')
          jail_temp_list.append('n/a')
          jail_temp_list.append('n/a')
       if i['active'] == 'dying':
          jail_temp_list[0] = jail_temp_list[0] + '_DYING'

       if mcmd[0] == 'jls':
           jail_temp_list = jail_temp_list[:6]
       jlist.append(jail_temp_list)

# table menu
   lmen = ["FLAGS", "ACTIVE", "JID", "NAME", "HOSTNAME", "IP ADDRESS", "GATEWAY", "PATH", "USED/AVAIL SPACE", "ZQUOTA",  "ZSNAP"]
# check if we use short list - jls
   if mcmd[0] == 'jls':
       lmen = ["FLAGS", "ACTIVE", "JID", "NAME", "HOSTNAME", "IP ADDRESS"]

   print tabulate(jlist, lmen)

def bytesto(bytes, to, bsize=1024):
   """
########################################################################################
# convert bytes to megabytes, etc.
# sample code:
# print('mb= ' + str(bytesto(314575262000000, 'm')))
#
# sample output:
# mb= 300002347.946
# from: https://gist.github.com/shawnbutts/3906915
   """

   a = {'K' : 1, 'M': 2, 'G' : 3, 'T' : 4, 'P' : 5, 'E' : 6 }
   r = float(bytes)
   for i in range(a[to]):
      r = r * bsize

   return(r)

def cleanlist(list):
   """
########################################################################################
# remove all empty '' elements from list
#
   """
   list = [x for x in list if x]
   return list

def ch_ipv4(sp):
    """
########################################################################################
# This function check if ip address fromat sp var is correct
# numbers of octet should be 4, each octet separated by '.' should be less than 256
#
    """
    octet = sp.split('.')
    if len(octet) != 4:
       return False
    try:
       return all(0<=int(p)<256 for p in octet)
    except ValueError:
       return False

def gateways(gwtable = None):
   """
########################################################################################
# find and display in table format existing bridge interfacess in system
#
   """

   bridges = []
   bridge_dict = {'name':'', 'addr':''}
# find all bridegX interfaces
   for i in netifaces.interfaces():
      if 'bridge' in i:
# fill all lists for bridge
         bridge_dict['addr'] = netifaces.ifaddresses(i)[netifaces.AF_INET]
         for x in bridge_dict['addr']:
            bridges.append({'name':i, 'addr':x})

# append os system default gateway
   system = subprocess.check_output('route get default', shell=True)
   system = system.split('\n')
   for i in system:
      i = i.split(':')
      if 'gateway' in i[0]:
         bridges.append({'name':'system', 'addr':{'addr':i[1].replace(' ', ''), 'broadcast':'', 'netmask':'' }})

# make final list TO BE FIXED
   gwlist = []
   gwname = 'n/a'
   for i in  bridges:
      if i['name'] == gwname:
          i['name'] = ' '
      gwlist.append([i['name'], i['addr']['addr'], i['addr']['netmask'], i['addr']['broadcast']])

# show gateway table
   if gwtable != None:
      lmen = ['INTERFACE', 'ADDRESS', 'NETWORKMASK', 'BROADCAST']
      print tabulate(gwlist, lmen)      

# return bridge interface name, ip addresses and network mask
   return (bridges)

def bridge_network_check(ip, bridge_ip, bridge_netmask):
   """
########################################################################################
# check if ipaddress is in selected bridge network
#
   """
# convert vars to unicode
   ip = unicode(ip)
   bridge_ip = unicode(bridge_ip)
   bridge_netmask = unicode(bridge_netmask)
# by default ip is not in bridge network
   brctl = 0

# bridge insterface ip network
   brdige_network = IPv4Interface('%s/%s' % (bridge_ip, bridge_netmask)).network

# check if ip is from bridge network and return bridge control var (brctl) = true
   if IPv4Address(ip) in list(IPv4Network(brdige_network)):
      brctl = 1

# return brctl and bridge ip network
   return brctl

def globals(action = None, setting = None):
   """
########################################################################################
#  manipulate jail global options list, remove or add new option
#
   """
   gsettings = load_jail_config(jailconf)[1]
# create globals list  
   num = 0
   gs = []
   for i in gsettings[1:]:
      gs.append([num, i[1]])
      num += 1

   lmen = ["GLOBALS SETTINGS"]
# show globals
   if action == None:
      print tabulate(gs, lmen)

# add new global setting
   elif action == 'add':
       if setting != None:
          update_jail_conf(['insert_line', [gsettings[-1][0], '%s;' % setting]])
          log(0, "'%s' global setting was added!" % setting, 1)

# remove existing global setting
   elif action == 'remove':
      try:
         rmset = gsettings.pop(int(setting) + 1)
         update_jail_conf(['rm_line', [rmset[0]]])
         log(1, "'%s' glabal setting was removed!" % rmset[1])
      except:
         print tabulate(gs, lmen)
         log(2, "'%s' is not a global setting number!" % setting, 1)
         return False
   else:
      log(2, "Please enter 'help globals' for valid commands!")

def locals(j = None, action = None, setting = None):
   """
########################################################################################
#  manipulate jail global options list, remove or add new option
#
   """
   gsettings = load_jail_config(jailconf)[0]

# find jail by id or name
   for i in gsettings:
      if str(i['name']) == str(j):
         jail = i
      elif str(i['jid']) == str(j):
         jail = i
      else:
         log(2, "'%s' was not found in jails!" % j)
         return False

# create jail locals list
   num = 0
   ls = []
   for i in jail['local_settings']:
      ls.append([num, i[1]])
      num += 1

   lmen = ["'%s' LOCALS SETTINGS" % jail['name']]

# list jail local settings
   if action == None:
      print tabulate(ls, lmen)

# add new jail local setting
   elif action == 'add':
       if setting != None:
          update_jail_conf(['insert_line', [jail['local_settings'][-1][0], '%s;' % setting]])
          log(0, "'%s' local setting was added to '%s' jail!" % (setting, jail['name']), 1)

# remove existing jail local setting
   elif action == 'remove':
      try:
         rmset = jail['local_settings'].pop(int(setting) + 1)
         update_jail_conf(['rm_line', [rmset[0]]])
         log(1, "'%s' local setting was removed from '%s' jail!" % (rmset[1], jail['name']), 1)
      except:
         print tabulate(ls, lmen)
         log(2, "'%s' is not a '%s' jail local setting number!" % (setting, jail['name']))
         return False
   else:
      log(2, "Please enter 'help locals' for valid commands!")


def update_jail_conf(update):
########################################################################################
# update or change jail.conf
#

# open jail.conf
   jc = open(jailconf, 'r')
   jcl = []
   for i in jc:
      i = i.strip('\n')
      jcl.append(i)
   jc.close()

   if update[0] == 'insert_line':
      jcl.insert(update[1][0], update[1][1])

   if update[0] == 'rm_line':
      del jcl[update[1][0]]

# close jail.conf
   jc = open(jailconf, 'w')
   jc.write('\n'.join(jcl))
   jc.close()

 
def log(ltype, msg, logit = None):
   """
########################################################################################
# print msg and log it if is needed
# log([0 - INFO, 1 = WARRNING and 2 - ERROR], 'log message', 'eny value if you want
#      to log in jailog file'
#
   """

   logtype = ['INFO', 'WARNING', 'ERROR']
   print "	%s: %s" % (logtype[ltype], msg)

   if logit != None:
      logging.basicConfig(format='%(asctime)s %(levelname)s: %(message)s', level=logging.DEBUG, filename=logfile)
      if ltype == 0:
         logging.info('   %s' % msg)
      if ltype == 1:
         logging.warning(msg)
      if ltype == 2:
         logging.error('  %s' % msg)

########################################################################################
# MAIN MENU
########################################################################################

class lcmd(cmd.Cmd):
   """
########################################################################################
#  interactive main menu with 'cmd' function
#
   """
   prompt = 'jadm:> '

   local_global = ['remove',  'add']
   snap = ['list', 'create',  'remove',  'restore']
   listcmd = ['list', 'hostname',  'ip',  'gw',
              'active',  'inactive', 'dying',
              'vnet', 'novnet', 'zfs', 'nozfs',
              'skel', 'noskel', 'quota', 'used', 'empty']
   mserver = ['server',  'client']

   def do_list(self, arg):
      """ List of jails in table format
      - FLAGS
      S - skeleton model jail
      V - vnet jail
      Z - zfs jail
      _DYING - dying jail

      - usage: list

      (search options)
      - only actvie jails (usage: list active)
      - only inactive jails (usage: list inactive)
      - only dying jails (usage: list dying)
      - no fully configured jails (usage: list empty)
      - by name (usage: list 'name/jid' )
      - by hostname (usage: list hostname 'jail hostname' )
      - by path (usage: lisy path '/jail/home/path' )
      - by ipaddress (usage: list ip 'ipaddress' )
      - by gateway (usage: list gw 'gateway ip' )
      - only vnet jails (usage: list vnet )
      - only none vnet jails (usage: list novnet )
      - only skel jails (usage: list skel )
      - only none skel jails (usage: list noskel )
      - only none zfs jails (usage list nozfs)
      --- apply only on zfs jails ---
      - only zfs jails (usage: list zfs)
      - by zfs quota (usage: list quota 'xxx('K', 'M', 'G', 'T', 'P', 'E')')
      show jails with quota = or > form x number
      - by zfs used space (usage: list used xxx('K', 'M', 'G', 'T', 'P', 'E')')
      show jails with used space = or > form x number
      """
      arg = str(arg).split(' ')

      if arg[0] != '':
         arg.insert(0,'list')
         arg = [i for i in arg if i != '']

      jail_table(arg)

   def complete_list(self, text, line, begidx, endidx):
      if not text:
         completions = self.listcmd[:]
      else:
         completions = [ f for f in self.listcmd if f.startswith(text)]
         return completions

   def do_jls(self,  arg):
      """ Short list of jails in table format
      - FLAGS
      S - skeleton model jail
      V - vnet jail
      Z - zfs jail
      _DYING - jails is dying

      - usage: jls

        same as list (show jails table in short format)
      """
      arg = str(arg).split(' ')
      arg.insert(0,'jls')
      arg = [i for i in arg if i != '']

      jail_table(arg)

   def complete_jls(self, text, line, begidx, endidx):
      if not text:
         completions = self.listcmd[:]
      else:
         completions = [ f for f in self.listcmd if f.startswith(text)]
         return completions

   def do_gateways(self,  arg):
      """ Show system 'bridgeX' interfaces 
          used for jail gateways and OS (system) default gateway 
      """

      gateways(gwtable = 1)
      
   def do_globals(self,  arg):
      """Globals settings
        - list of globals settings (usage: global)
        - remove global setting (usage: global remove 'setting number' )
        - add global setting (usage: global add 'setting=val')
      """

      arg = str(arg).split(' ')
      arg = [i for i in arg if i != '']
 
      if len(arg) > 1:     
         globals(arg[0], arg[1])
      else:
         globals()

   def complete_globals(self, text, line, begidx, endidx):
      if not text:
         completions = self.local_global[:]
      else:
         completions = [ f for f in self.local_global if f.startswith(text)]
         return completions

   def do_locals(self,  arg):
      """Jails Locals settings
        - list of jail locals settings (usage: locals 'name/jid')
        - remove jail local setting (usage: locals 'name/jid' remove 'setting number' )
        - add jail local setting (usage: locals 'name/jid' add 'setting=val')
      """

      arg = str(arg).split(' ')
      arg = [i for i in arg if i != '']

      if len(arg) == 3:
         locals(arg[0], arg[1], arg[2])
      elif len(arg) == 1:
         locals(arg[0])
      else:
         log(2, "Please enter 'help locals' for valid commands!")

   def complete_locals(self, text, line, begidx, endidx):
      if not text:
         completions = self.local_global[:]
      else:
         completions = [ f for f in self.local_global if f.startswith(text)]
         return completions

def cli():
   """
########################################################################################
#  jadm command line interface
#
   """
   if sys.argv[1] in ['-y', '-v', '-c', '-m', '-i']:

# cli verbose mode for start/stop jail
         if sys.argv[1] == '-v':
            verbose = 1
            # prtin and add to log file
            logmsg = "      INFO: verbose mode enable"
            log(logmsg)

# cli auto confirm

         if '-y' in sys.argv:
            sys.argv[ sys.argv.index('-y')] = 'autoConfirm:yes'
         else:
             sys.argv.append('autoConfirm:no')

# cli create jail
         if sys.argv[1] == '-c':
            jail_create_cli(sys.argv)
            sys.exit(0)

# cli modify jail
         if sys.argv[1] == '-m':
            print "jadm cli modify"
            sys.exit(0)


# cli jail - os info
         if sys.argv[1] == '-i':
            welcome()
            sys.exit(0)

         jadmCommand = ' '.join(sys.argv[2:])
   else:
      jadmCommand = ' '.join(sys.argv[1:])

# cli command
   lcmd().onecmd(jadmCommand)

########################################################################################
# Start Jadm script
########################################################################################

if len(sys.argv) > 1:
# use cli interface
   cli()
else:
# main menu shell
   lcmd().cmdloop()

########################################################################################
# End Jadm script
########################################################################################
